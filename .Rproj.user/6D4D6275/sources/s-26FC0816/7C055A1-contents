---
title: "Premier point d'?tape sur le recodage d'Ines"
author: "Antoine Sireyjol"
date: "9 novembre 2018"
output:
  ioslides_presentation: 
    incremental: yes
    widescreen: yes
  slidy_presentation: 
    incremental: yes
  beamer_presentation: 
    colortheme: beaver
    fonttheme: professionalfonts
    incremental: yes
    theme: CambridgeUS
    toc: yes
---

```{r setup, include=FALSE}
library(knitr)
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_chunk$set(message = TRUE)
knitr::opts_chunk$set
library(reticulate)
use_python("C:/Users/antoi/Anaconda3/envs/openfisca/python.exe", required=TRUE)
library(ggplot2)
library(data.table)
library(tidyverse)

library(haven)

mon_chemin <- "C:/Users/antoi/Documents/Bases Ines Leg 17 Ref 15 brouill?es/Base 2015/base/"
baserev <- read_sas(paste(mon_chemin, "baserev.sas7bdat", sep=""))
basemen <- read_sas(paste(mon_chemin, "menage17.sas7bdat", sep=""))
# On grossit artificiellement baserev
baserev <- do.call("rbind", replicate(30, baserev[is.na(baserev$zsali15) == F, ], simplify = FALSE))
# on transforme des exemplaires de table en data.table pour les exemples concernant ce package
baserevdt <- data.table::data.table(baserev)
basemendt <- data.table::data.table(basemen)
# on transforme des exemplaires de table en tibbles pour les exemples concernant dplyr (mais marche avec des data.frame)
baserevtib <- as_tibble(baserev)
basementib <- as_tibble(basemen)
# On cr?e un param?tre l?gislatif
montant_forfaitaire <- 5000
```

## Plan de la pr?sentation {.flexbox .vcenter}

- Recodage en R : revue des diff?rentes options  

- Openfisca et python  

- Synth?se des diff?rentes options  

- WPS

# Possibilit?s de recodage en R

## Base R {.flexbox .vcenter .build}

- Usage de base R a priori possible pour recoder les instructions Ines

- Probl?me : syntaxe parfois un peu lourde pour le traitement de donn?es

- Moins facile de coder en base R qu'avec les syntaxes `dplyr` et `data.table`

- Les tests de rapidit? du rapport montraient que les fonctions de base R pouvaient ?tre plus lentes

## Exemple de code en base R {.flexbox .vcenter .build .smaller}

```{r echo=TRUE, message=FALSE, warning=FALSE, paged.print=FALSE}
baserev1 <- baserev
baserev1$ressources1 <- baserev1$zsali15 + baserev1$zchoi15 + baserev1$zrsti15
baserev1$montant_droit1 <- pmax(0, montant_forfaitaire - baserev1$ressources1)
agreg <- tapply(baserev1$montant_droit1, baserev1$ident, sum)
basemen1 <- base::merge(data.frame(ident = names(agreg), montant_droit1 = agreg),
                      basemen, by = "ident")
basemen_eli1 <- basemen1[basemen1$montant_droit1 > 0, ]
```

## Data.table {.flexbox .vcenter}

- Format optimis? de data.frame

- Compl?mentaire ? base R

- Optimisation de l'op?rateur `[`

- Cha?nage possible des instructions

- Plus lisible, plus rapide

## Le code en data.table {.flexbox .vcenter .smaller}

```{r echo=TRUE, message=FALSE, warning=FALSE, paged.print=FALSE}
baserev3 <- baserevdt
baserev3[, ressources3 := zsali15 + zchoi15 + zrsti15][
  , montant_droit3 := pmax(0, montant_forfaitaire - ressources3)][
  , list(montant_droit3 = sum(montant_droit3)),
  by = list(ident = ident)] -> baserev3 
basemen_eli3 <- merge(baserev3, basemendt, by="ident")[montant_droit3>0, ]
```


## Dplyr et le tidyverse {.flexbox .vcenter}

- Tidyverse : environnement d'analyse de donn?es en R

- Propre format de donn?es : le tibble

- Syntaxe caract?ristique et concurrente des fonctions de base R avec `dplyr`

- Cha?nage possible des instructions avec `%>%`

- Tr?s lisible et ?galement optimis?

## Le code en dplyr {.flexbox .vcenter .smaller}

```{r echo=TRUE, message=FALSE, warning=FALSE, paged.print=FALSE}
baserev2 <- baserevtib
baserev2 %>% 
  mutate(ressources2 = zsali15 + zchoi15 + zrsti15,
         montant_droit2 = pmax(0, montant_forfaitaire - ressources2)) %>% 
         group_by(ident) %>% 
         summarise(montant_droit2 = sum(montant_droit2)) %>% 
         right_join(basementib, by = "ident") %>% 
         filter(montant_droit2>0) -> basemen_eli2
  
```



## Efficacit? des options {.flexbox .vcenter}

- On compare les 3 options ? l'aide de la fonction microbenchmark :

```{r echo=F, message=FALSE, warning=FALSE, paged.print=FALSE}
rm(basemen1, basemen_eli1, basemen2, basemen_eli2, basemen3, basemen_eli3)
autoplot(microbenchmark::microbenchmark(times=30L,Base={
        baserev1 <- baserev
        baserev1$ressources1 <- baserev1$zsali15 + baserev1$zchoi15 + baserev1$zrsti15
        baserev1$montant_droit1 <- pmax(0, montant_forfaitaire - baserev1$ressources1)
        agreg <- tapply(baserev1$montant_droit1, baserev1$ident, sum)
        basemen1 <- base::merge(data.frame(ident = names(agreg), montant_droit1 = agreg),
                              basemen, by = "ident")
        basemen_eli1 <- basemen1[basemen1$montant_droit1 > 0, ]
}, DplyR = {
      baserev2 <- baserevtib
      baserev2 %>% 
        mutate(ressources2 = zsali15 + zchoi15 + zrsti15,
               montant_droit2 = pmax(0, montant_forfaitaire - ressources2)) %>% 
               group_by(ident) %>% 
               summarise(montant_droit2 = sum(montant_droit2)) %>% 
               right_join(basementib, by = "ident") %>% 
               filter(montant_droit2>0) -> basemen_eli2
}, Data.Table = {
    baserev3 <- baserevdt
    baserev3[, ressources3 := zsali15 + zchoi15 + zrsti15][
      , montant_droit3 := pmax(0, montant_forfaitaire - ressources3)][
      , list(montant_droit3 = sum(montant_droit3)),
      by = list(ident = ident)] -> baserev3 
    basemen_eli3 <- merge(baserev3, basemendt, by="ident")[montant_droit3>0, ]
}))
```

## Et SAS en fait? {.flexbox .vcenter .smaller}

```
%let debut_chrono = %sysfunc(time());
data baserev;
	set baserev;
	ressources = zsali15 + zchoi15 + zrsti15;
	montant_droit = max(0, &montant_forfaitaire. - ressources);
	run;
	
proc means data = baserev noprint; var montant_droit; 
  class ident; output out = baserevbis sum = montant_droit0; 
  run;

data basemen0 (where = (montant_droit0 > 0));
	merge basemen baserevbis;
	by ident;
	run;
	
%put %sysevalf((%sysfunc(time()) - &debut_chrono.) * 1000);
```
- Donne des temps sup?rieurs ? 170 ms

# Openfisca et python

## Logique du calculateur {.flexbox .vcenter}

- Programmation objet : souplesse de l'outil

- Les objets de openfisca-france sont cr??s dans openfisca-core

- Exemple de l'objet variable : 

## {.flexbox .vcenter .build .smaller}

```
class Variable(object):
  def __init__(self, baseline_variable = None):
        self.name = to_unicode(self.__class__.__name__)
        attr = {
            name: value for name, value in self.__class__.__dict__.items()
            if not name.startswith('__')}
        self.baseline_variable = baseline_variable
        self.value_type = self.set(attr, 'value_type', required = True, allowed_values = VALUE_TYPES.keys())
        self.dtype = VALUE_TYPES[self.value_type]['dtype']
        self.json_type = VALUE_TYPES[self.value_type]['json_type']
        if self.value_type == Enum:
            self.possible_values = self.set(attr, 'possible_values', required = True, setter = self.set_possible_values)
        if self.value_type == str:
            self.max_length = self.set(attr, 'max_length', allowed_type = int)
            if self.max_length:
                self.dtype = '|S{}'.format(self.max_length)
        if self.value_type == Enum:
            self.default_value = self.set(attr, 'default_value', allowed_type = self.possible_values, required = True)
        else:
            self.default_value = self.set(attr, 'default_value', allowed_type = self.value_type, default = VALUE_TYPES[self.value_type].get('default'))
        self.entity = self.set(attr, 'entity', required = True, setter = self.set_entity)
        self.definition_period = self.set(attr, 'definition_period', required = True, allowed_values = (MONTH, YEAR, ETERNITY))
        self.label = self.set(attr, 'label', allowed_type = basestring_type, setter = self.set_label)
        self.end = self.set(attr, 'end', allowed_type = basestring_type, setter = self.set_end)
        self.reference = self.set(attr, 'reference', setter = self.set_reference)
        self.cerfa_field = self.set(attr, 'cerfa_field', allowed_type = (basestring_type, dict))
        self.unit = self.set(attr, 'unit', allowed_type = basestring_type)
        self.documentation = self.set(attr, 'documentation', allowed_type = basestring_type, setter = self.set_documentation)

```

## Logique du calculateur {.flexbox .vcenter}

- Programmation objet : souplesse de l'outil

- Les objets de openfisca-france sont cr??s dans openfisca-core

- Exemple de l'objet variable : 

- Cet objet est ensuite utilis? au moment de la d?finition d'une nouvelle variable :

## {.flexbox .vcenter .smaller}

```
class af_nbenf(Variable):
    value_type = int
    entity = Famille
    label = u"Nombre d'enfants dans la famille au sens des allocations familiales"
    definition_period = MONTH

    def formula(famille, period):
        prestations_familiales_enfant_a_charge_i = 
        famille.members('prestations_familiales_enfant_a_charge', period)
        
        af_nbenf = famille.sum(prestations_familiales_enfant_a_charge_i)

        return af_nbenf

```


## Avantages et inconv?nients {.flexbox .vcenter .build}

- Avantages :  

    - Outil optimis? et performant
    - Regroupement des ressources (mise ? jour, maintenance...)
    - Souplesse de l'objet  : grand nombre de possibilit?s  
    
- Inconv?nients :     

    - Le microsimulateur n'a plus enti?rement la main sur le mod?le
    - Incertitudes sur le raccordement ? l'ERFS
    - Abandon d'Ines...



## Une alternative sur python : pandas {.flexbox .vcenter .build}

- Librairie de pythons pour traitement de donn?es

- Logique proche de R : objets dataframe et series

- Bonnes performances

## Le m?me code en pandas {.flexbox .vcenter .build .smaller}

```

import pandas as pd
import numpy as np

mon_chemin = "C:\\Users\\antoi\\Documents\\Bases Ines Leg 17 Ref 15 brouill?es\\Base 2015\\base\\"
baserev = pd.read_sas(f"{mon_chemin}baserev.sas7bdat")
# On enl?ve tout de suite la valeur manquante
baserevpy = baserev.loc[pd.isnull(baserev["zsali15"]) == False, ] 

baserevpy1 = baserevpy
baserevpy1["ressources"] = baserevpy1["zsali15"] + baserevpy1["zchoi15"] + baserevpy1["zrsti15"]
baserevpy1["montant_droit"] = np.maximum(0,montant_forfaitaire - baserevpy1["ressources"])
agreg = baserevpy1.groupby('ident', as_index = False)['montant_droit'].sum()
basemenpy = basemen.merge(agreg, how="left", on="ident") 
basemen_elipy = basemenpy.loc[basemenpy["montant_droit"] > 0, ]  


```
---

```{r echo=FALSE}
#Cr?ation du tableau
t <- c("min","1er quartile","moyenne","m?diane", "3e quartile", "max", "nbeval")
u <- c("11","16","18","16", "16", "32", "30")
tableau <- cbind(t, u)
kable(tableau, col.names = c(" ", "Temps d'ex?cution (en ms) "))
```
 

# Synth?se des diff?rentes options

---
```{r echo=FALSE}
#Cr?ation du tableau
a <- c("Facilit? de la formation", "Lisibilit? du mod?le"
     , "Efficacit? du langage", "Temps de mise en oeuvre du changement de langage", "Possibilit? d'une transition progressive", "Proximit? des sorties au mod?le actuel")
b <- c("?","-","++","+","--","?")
c <- c("+","-","++","-","+","+")
d <-c ("+","-","++","-","++","+")
e <-c ("+","+","+","-","++","+")
tableau <- cbind(a, b, c, d, e)
kable(tableau, col.names = c("Caract?ristiques","Python (openfisca)", "Python (pandas)","R (orient? data.table)", "R (orient? dplyr)"))
```
  
- Ces crit?res sont-ils pertinents? En voyez-vous d'autres?
- M?me un choix orient? donn?es devrait ?tre accompagn? d'une r?flexion "objet" pour optimiser Ines


# WPS

## Une plateforme avec SAS ? moindre co?t {.flexbox .vcenter .build}

- IDE avec SAS, R et Python

- Possibilit? d'envoyer les codes SAS pour v?rifier la compatibilit?

- Int?ressant seulement si volont? de rester sur SAS ? moyen terme
  
# On en discute?
